严格来讲v1版本使用的是递归，并不是O(1)的空间复杂度。

核心思路是用快慢指针，将整个链表分为两个部分，然后再用递归的方式不断往下分，直到只剩两个元素。
利用归并排序的思路对元素排序。由于是链表，这步排序操作只需要使用常量的空间。

空间复杂度O(log n) // 递归
时间复杂度O(n log n) // 归并排序。需要遍历log n次链表。

V2版本：自下而上的归并。

要使用常量空间就意味着无法用递归。所以要采用自下而上的归并排序方法。

相比于使用递归，此时难点在于如何跳出循环，因为链表无法知道len的取值范围。
（其实可以提前遍历一遍链表，得到size，逻辑上会简单些）

这里选择在每次排序后返回tailNode，当tailNode==null时，意味着已经到底，即完成一次遍历。

随着len的增大，归并排序的范围也越来越大，只要需要>=2次的调用，意味着len<= size/2的。即还没完成排序。

如果一次sort直接返回null，说明len已经足够大，即表示已经完成排序。
```scala
while(preNode != null){
  while (preNode != null){
    // 遍历数组，直到到达尾部
    preNode = sortSubList(preNode, len)
  }
  // 准备二次遍历
  preNode = dummyHead
  len *= 2
  // 遍历一次，如果已经完成排序，则会返回null(len足够长)。否则意味着还需要继续排序。
  // 如要是帮助跳出循环，因为无法知道链表的长度（无法直接确定len的值）。
  preNode = sortSubList(preNode, len)
}
``` 


